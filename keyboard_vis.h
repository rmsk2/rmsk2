/***************************************************************************
 * Copyright 2015 Martin Grap
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ***************************************************************************/

#ifndef __keyboard_vis_h__
#define __keyboard_vis_h__

/*! \file keyboard_vis.h
 *  \brief Header file for the GUI classes that implement the keyboard visualizers that are used by enigma and rotorvis.
 */ 

#include<sigc++/functors/slot.h>
#include<alphabet.h>
#include<base_elements.h>
#include<output_device.h>
#include<rotor_machine.h>

/*! \brief A GUI class that encapsulates the notion of a keyboard with a certain sequence of keys that is drawn in a Cairo context.
 *
 *  Objects of this type provide an abstract interface to the simulated keyboard of a rotor machine. Client code is made unaware that there are
 *  several individual keys and simply can deal with the keyboard as a whole. 
 *
 *  A keyboard_base object (or an object of an appropriate child) is the main hub for generating input and output values in a graphical rmsk based rotor
 *  machine simulator as the method keyboard_base::process_key_press() passes the input keycode generated by the keyboard through the rotor machine
 *  and its associated ::printing_device in order to create the desired output.
 *
 *  The keys in a keyboard are arranged in rows. The member keyboard_base::line_breaks specifies the number of keys in the first, second, ..., second but last
 *  rows. Default is the Enigma layout 9 (first row), 8 (second row), 9 (third row). This can be changed by calling the method keyboard_base::set_line_breaks().
 *  The current sequence of the keys as they appear in the GUI is stored in the member variable keyboard_base::std_keys. Default is "qwertzuioasdfghjkpyxcvbnml".
 *
 *  Apart from the sequence of the keys as they appear in the GUI another piece of information is needed by keyboard_base objects: The so called keycode
 *  alphabet. It specifies how characters are mapped to keycodes in the context of the simulated rotor machine. Normally the keycode alphabet is
 *  "abcdefghijklmnopqrstuvwxyz". The exception is the Nema where the keycode alphabet is "ijklmnopqrstuvwxyzabcdefgh". 
 *
 *  When a new keyboard_base object is created the constructor generates the necessary ::key objects and stores them in the keyboard_base::keys member
 *  variable. Optionally a keyboard_base object can draw and manage an additional space bar, which is achieved by calling the keyboard_base::add_space_bar()
 *  method.
 *
 *  ToDo: Rethink how to draw the keyboard. The connection between draw_parameters and the element position is confusing.
 */
class keyboard_base : public element {
public:
    /*! \brief Constructor. The parameters pos_x and pos_y have to specify the position where the keyboard is to be drawn. The callbacks enc_state_func,
     *         get_machine and update_func serve the purpose to decouple the keyboard_base class from the ::rotor_draw class.
     *
     *  (pos_x, pos_y) specifies the position where the first key in the first row is drawn. The enc_state_func callback has to return True if the simulator
     *  is currently doing encryptions and False otherwise. The get_machine parameter has to return the rotor_machine object that is currently in use
     *  in the simulator and finally the update_func callback is intended to allow the keyboard to redraw the visualized rotor stack after the rotors
     *  have been advanced by pressing a key on the keyboard.
     */
    keyboard_base(int pos_x, int pos_y, sigc::slot<bool> enc_state_func, sigc::slot<rotor_machine *> get_machine, sigc::slot<void, Cairo::RefPtr<Cairo::Context> > update_func);

    /*! \brief Draws the keyboard into the drawing context specified by parameter cr.
     */            
    virtual void draw(Cairo::RefPtr<Cairo::Context> cr);
    
    /*! \brief Returns true if the keyboard is active and the point (pos_x, pos_y) is inside of any of the individual keys managed this object.
     */            
    virtual bool test(int pos_x, int pos_y);

    /*! \brief Allows to tell the keyboard which ::output_device object is in use by the simulator. Knowing this object allows the keyboard to
     *         control the lampboard or simulated printer that is used to visualize the rotor machine output.
     *
     *  keyboard_base does not take ownership of the object passed to it through the parameter new_output_device. I.e. this object is not deleted
     *  by keyboard_base::~keyboard_base().
     */            
    virtual void set_output_device(output_device *new_output_device) { output = new_output_device; }

    /*! \brief Returns a reference to a signal that is emitted when processing a key press. The signal specifies the input character that has
     *         been processed by the keyboard. To be more precise: The input character is generated by the ::rotor_keyboard object associated
     *         with the underlying ::rotor_machine object.
     */            
    virtual sigc::signal<void, gunichar>& signal_input_char() { return input_char; }

    /*! \brief Returns a reference to a signal that is emitted when processing a key press. The signal specifies the output character that has
     *         been created by the ::printing_device of the underlying ::rotor_machine.
     */            
    virtual sigc::signal<void, gunichar>& signal_output_char() { return output_char; }

    /*! \brief Returns a reference to a signal that is emitted when processing a key press. The signal specifies the input and output keyocde values
     *         as they have been created by the keyboard and the underlying ::rotor_machine object.
     */            
    virtual sigc::signal<void, unsigned int, unsigned int>& signal_inout_value() { return inout_value; }

    /*! \brief Returns a reference to a signal that is emitted when a key is released.
     */            
    virtual sigc::signal<void>& signal_key_up() { return key_up; }

    /*! \brief Allows to change the keycode alphabet in use by this keyboard_base object to the new value specified by the parameter alpha.
     *         keyboard_base objects do not take ownership of the object to which alpha points. The specified alphabet is cloned by this method.
     */                
    virtual void set_keycode_alpha(alphabet<gunichar> *alpha);  
    
    /*! \brief Allows to change the sequence of keys as the appear in the GUI. The parameter sequence_of_keys has to specify the sequence of
     *         the keys when read from top left to bottom right.
     *
     *  Any machine that has a key sequence different of the Enigma default "qwertzuioasdfghjkpyxcvbnml" has to call this method using an     
     *  appropriate parameter (i.e. "qwertyuiopasdfghjklzxcvbnm" for machines of UK or US origin).
     */                
    virtual void permute_key_sequence(ustring sequence_of_keys);

    /*! \brief Allows to change the sequence of keys as the appear in the GUI as well as the keycode alphabet. The parameter sequence_of_keys
     *         has to specify the sequence of the keys when read from top left to bottom right. The parameter keycode_alpha has to point
     *         to the new keycode alphabet. The specified alphabet is cloned by this method.
     *
     *  In contrast to permute_key_sequence this method recreates all keys in this keyboard_base object to mach the new key sequence and keycode
     *  alphabet.
     */
    virtual void set_key_sequence(ustring sequence_of_keys, alphabet<gunichar> *keycode_alpha);

    /*! \brief Allows to change the positions in the sequence of keys that signify the start of the second row (parameter break_line_1) and
     *         the third row (parameter break_line_2).
     *
     *  As the positions in the sequence of keys are zero based break_line_1 really specifies the first position in the second row. The same
     *  applies to break_line_2 with respect to third row.  
     */                
    virtual void set_line_breaks(unsigned int break_line_1, unsigned int break_line_2); 

    /*! \brief Allows to change the positions in the sequence of keys that signify the start of the rows in which the keys are arranged.
     *         The parameter new_line_breaks has to specifiy the new line breaks to use.
     */                
    virtual void set_line_breaks(vector<unsigned int>& new_line_breaks);

    /*! \brief This method allows to simulate a key press by essentially calling keyboard_base::process_key_press and keyboard_base::process_key_release.
     *         The parameter simulated_key has to specifiy the character that is to bre processed and the parameter cr has to specifiy a Cairo context
     *         for drawing.
     *
     *  This method is intended to simulate the processing of keyboard events. It's purpose is to allow processing of inputs that are not generated by
     *  clicking on simulated keys or pressing keys on the real computer keyboard. In rotorvis and Enigma this method is used to process texts that
     *  are stored in the clipboard.
     */            
    virtual void simulate_key_press(Cairo::RefPtr<Cairo::Context> cr, gunichar simulated_key);

    /*! \brief Returns the ::draw_parameters that are in use in this instance of keyboard_base.
     */                
    virtual draw_parameters get_draw_parameters() { return draw_param; }

    /*! \brief Allows to change the ::draw_parameters that are in use in this instance of keyboard_base to the new value speicifed in parameter
     *         new_params.
     */                
    virtual void set_draw_parameters(draw_parameters new_params) { draw_param = new_params; }

    /*! \brief Allows to change the position where the keyboard_base object is drawn. The point (new_x, new_y) specifies the positon of the first key
     *         in the sequence of keys (i.e. keyboard_base::std_keys).
     */                
    virtual void set_elem_pos(int new_x, int new_y);

    /*! \brief This method should be called when the key contained in parameter key has been pressed on the real computer keyboard.
     */                
    virtual void on_key_press(Cairo::RefPtr<Cairo::Context> cr, gunichar key);

    /*! \brief This method should be called when the key contained in parameter key has been released on the real computer keyboard.
     */                
    virtual void on_key_up(Cairo::RefPtr<Cairo::Context> cr, gunichar key);

    /*! \brief This method should be called when the left mouse button has been released.
     */                
    virtual void on_mouse_button_up(Cairo::RefPtr<Cairo::Context> cr);

    /*! \brief This method should be called when the left mouse button has been clicked on position (pos_x, pos_y).
     */                
    virtual void on_mouse_button_down(Cairo::RefPtr<Cairo::Context> cr, int pos_x, int pos_y);

    /*! \brief This method instructs the keyboard_base object to draw an additional space bar (see ::space_bar) of specified width and height.
     *         The parameter alternate_key specifies which original key is attached to the ::space_bar.
     */                
    virtual void add_space_bar(int width, int height, char alternate_key);        

    /*! \brief Destructor. Deletes all key objects.
     */                    
    virtual ~keyboard_base();       

protected:
    /*! \brief Replaces the current set of keys with the ones specified in parameter new_keys.
     *
     *  This method deletes the keys which are currently in use before setting up the new keys.
     */                    
    virtual void set_keys(std::map<unsigned int, key*>& new_keys);

    /*! \brief This is the method where all the processing happens that is necessary to encrypt or decrypt a keycode. It is called
     *         independent of the source (real computer keyboard, mouse click, simulated key press) of a key press event.
     */                    
    virtual void process_key_press(Cairo::RefPtr<Cairo::Context> cr, unsigned int key_pressed);

    /*! \brief Performs the cleanup operations necessary after the current key has been released. This method is called
     *         independent of the source (real computer keyboard, mouse click, simulated key press) of a key release event.
     */
    virtual void process_key_release(Cairo::RefPtr<Cairo::Context> cr); 
    
    /*! \brief Determines the keycode that belongs to the symbol that is given in parameter in. This is done via the the ::printing_device or
     *         ::rotor_keyboard of the underlying ::rotor_machine depending on whether encryptions or decryptions are performed.
     */        
    virtual unsigned int get_key_code(gunichar in);

    /*! \brief Determines whether the symbol that is given in parameter in is currently valid (i.e. contained in the currently valid
     *         input alphabet). This is done via the the ::rotor_keyboard of the underlying ::rotor_machine.
     */        
    virtual bool is_symbol_valid(gunichar in);

    /*! \brief Returns a new set of keys where the labels are determined by keyboard_base::std_keys and the alphabet specified in parameter
     *         alpha is used as a keycode alphabet.
     */            
    std::map<unsigned int, key*> create_std_key_board(alphabet<gunichar> *alpha);

    /*! \brief Adapts the positions of the 26 keys according to the position of the keyboard_base and the drawing parameters
     *         (see keyboard_base::draw_param).
     */            
    void set_key_positions();

    /*! \brief Adapts the position of the optional ::space_bar according to the position of the keyboard_base and the drawing parameters
     *         (see keyboard_base::draw_param).
     */
    void set_space_bar_pos();

    /*! \brief Holds the 26 keys of the keyboard. */                    
    std::map<unsigned int, key*> keys;
    
    /*! \brief Is true if a key currently depressed. */                    
    bool key_is_pressed;
    
    /*! \brief Determines the source of the last recorded key press event. Can be PRESS_KEYBOARD, PRESS_MOUSE or PRESS_NONE. */                        
    unsigned int press_event_source;
    
    /*! \brief Points to the currently depressed key. Or is NULL in case no key is currently depressed. */    
    key *current_key;
    
    /*! \brief Points to the space_bar object. Is NULL, if no space_bar is currently in use. */    
    space_bar *space;
    
    /*! \brief Holds a pointer to the ::output_device which is in use in the simulator. */    
    output_device *output;
    
    /*! \brief Holds a pointer to the keycode alphabet. */        
    boost::shared_ptr<alphabet<gunichar> > keycode_alpha;
    
    /*! \brief Holds signal that is emitted to signify the input symbol that has been processed. */        
    sigc::signal<void, gunichar> input_char;
    
    /*! \brief Holds signal that is emitted to signify the out symbol that has been produced. */            
    sigc::signal<void, gunichar> output_char;
    
    /*! \brief Holds signal that is emitted to signify the input and output keycodes that have been processed/produced. */    
    sigc::signal<void, unsigned int, unsigned int> inout_value;
    
    /*! \brief Holds signal that is emitted to signify that a key has been released. */    
    sigc::signal<void> key_up;   
    
    /*! \brief Holds the draw_parameters that are in use in this keyboard_base object. */    
    draw_parameters draw_param;
    
    /*! \brief Holds the current sequence of keys. */    
    ustring std_keys;
    
    /*! \brief Holds the line breaks which specify where in keyboard_base::std_keys the second and third rows of keys begin. */    
    vector<unsigned int> line_breaks;     
    
    /*! \brief Holds a callback that allows to determine whether the simulator is currently doing encryptions or decryptions. */
    sigc::slot<bool> enc_state;
    
    /*! \brief Holds a callback that allows to retrieve the underlying ::rotor_machine. */    
    sigc::slot<rotor_machine *> machine;
    
    /*! \brief Holds a callback that allows to redraw the visualized rotor stack. */    
    sigc::slot<void, Cairo::RefPtr<Cairo::Context> > rotor_update;           
    
};

/*! \brief A GUI class that knows how to draw an Enigma style keyboard into a Cairo drawing context.
 *
 *  This class is more or less indentical to ::keyboard_base.
 */            
class enigma_keyboard : public keyboard_base {
public:
    /*! \brief Constructor. Only the callbacks enc_state_func, get_machine and update_func have to be specified. The position defaults to (KEY_ROW_THREE_X_OFFSET, KEY_ROW_ONE_Y).
     */            
    enigma_keyboard(sigc::slot<bool> enc_state_func, sigc::slot<rotor_machine *> get_machine, sigc::slot<void, Cairo::RefPtr<Cairo::Context> > update_func);

    /*! \brief Constructor. The callbacks enc_state_func, get_machine and update_func have to be specified and position (pos_x, pos_y) of the keyboard have to be 
     *         specified.
     */            
    enigma_keyboard(int pos_x, int pos_y, sigc::slot<bool> enc_state_func, sigc::slot<rotor_machine *> get_machine, sigc::slot<void, Cairo::RefPtr<Cairo::Context> > update_func);
  
    /*! \brief Destructor.
     */                
    virtual ~enigma_keyboard() { ; }
};

/*! \brief A GUI class that knows how to draw a KL7 style keyboard into a Cairo drawing context.
 *
 *  This class is more or less indentical to ::keyboard_base. The only difference to the base class is that the labeling of the first row of keys
 *  also contains numbers.
 */            
class kl7_keyboard : public keyboard_base {
public:
    /*! \brief Constructor. Only the callbacks enc_state_func, get_machine and update_func have to be specified. The position defaults to (KEY_ROW_THREE_X_OFFSET, KEY_ROW_ONE_Y).
     */            
    kl7_keyboard(sigc::slot<bool> enc_state_func, sigc::slot<rotor_machine *> get_machine, sigc::slot<void, Cairo::RefPtr<Cairo::Context> > update_func);

    /*! \brief Constructor. The callbacks enc_state_func, get_machine and update_func have to be specified and position (pos_x, pos_y) of the keyboard have to be 
     *         specified.
     */            
    kl7_keyboard(int pos_x, int pos_y, sigc::slot<bool> enc_state_func, sigc::slot<rotor_machine *> get_machine, sigc::slot<void, Cairo::RefPtr<Cairo::Context> > update_func);

    /*! \brief Destructor.
     */                    
    virtual ~kl7_keyboard() { ; }

protected:
    /*! \brief Adapts labeling.
     */                
    void modify_labelling();
};

/*! \brief A GUI class that knows how to draw a Typex style keyboard into a Cairo drawing context.
 *
 *  This class is more or less indentical to ::keyboard_base. The only difference to the base class is that the labeling of most keys is changed
 *  to additionally show the characters that can be produced in figures mode.
 */            
class typex_keyboard : public keyboard_base {
public:
    /*! \brief Constructor. Only the callbacks enc_state_func, get_machine and update_func have to be specified. The position defaults to (KEY_ROW_THREE_X_OFFSET, KEY_ROW_ONE_Y).
     */            
    typex_keyboard(sigc::slot<bool> enc_state_func, sigc::slot<rotor_machine *> get_machine, sigc::slot<void, Cairo::RefPtr<Cairo::Context> > update_func);

    /*! \brief Constructor. The callbacks enc_state_func, get_machine and update_func have to be specified and position (pos_x, pos_y) of the keyboard have to be 
     *         specified.
     */
    typex_keyboard(int pos_x, int pos_y, sigc::slot<bool> enc_state_func, sigc::slot<rotor_machine *> get_machine, sigc::slot<void, Cairo::RefPtr<Cairo::Context> > update_func);

    /*! \brief Destructor.
     */                        
    virtual ~typex_keyboard() { ; }

protected:
    /*! \brief Adapts labeling.
     */                
    void modify_labelling();
};

#endif /* __keyboard_vis_h__ */

